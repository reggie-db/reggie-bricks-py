<!doctype html>
<html lang="en" class="h-full overflow-hidden">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <title>Webcam Stream Client</title>
    <style>
        * {
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        input,
        textarea {
            touch-action: manipulation;
            -webkit-user-select: auto;
            user-select: auto;
        }

        body {
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        html {
            overscroll-behavior: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }
    </style>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'db-blue': '#0094FF',
                        'db-blue-hover': '#007ACC',
                        'db-text': '#1F2937',
                        'db-text-secondary': '#6B7280',
                        'db-bg': '#FFFFFF',
                        'db-card': '#F7F9FC',
                        'db-border': '#E5E7EB',
                    }
                }
            }
        }
    </script>
    <script type="module">
        import {
            uniqueNamesGenerator,
            adjectives,
            colors,
            animals
        } from 'https://cdn.jsdelivr.net/npm/@joaomoreno/unique-names-generator@5.2.0/+esm';

        window.randomName = uniqueNamesGenerator({
            dictionaries: [adjectives, colors, animals],
            separator: "-",
            style: "lowerCase",
        });
    </script>
</head>

<body class="h-full w-full overflow-hidden bg-db-bg text-db-text font-sans p-1 sm:p-2 flex items-center justify-center">
    <div
        class="bg-db-card border border-db-border rounded-lg p-3 sm:p-4 w-full max-w-md max-h-full shadow-sm flex flex-col gap-2 sm:gap-3 overflow-hidden">
        <h2 class="text-lg sm:text-xl font-semibold text-db-blue m-0">IOT Stream</h2>
        <div
            class="flex-shrink-0 max-h-[40vh] sm:max-h-[50vh] flex items-center justify-center bg-black rounded-lg overflow-hidden my-1">
            <video id="video" autoplay playsinline muted
                class="w-full h-full max-w-full max-h-full object-contain rounded-lg"></video>
        </div>
        <div class="flex flex-col text-left flex-shrink-0">
            <label for="streamId" class="text-xs sm:text-sm text-db-text-secondary font-medium mb-1">Stream ID</label>
            <input id="streamId" type="text" placeholder="Stream ID"
                class="border border-db-border rounded-lg px-2 sm:px-3 py-1.5 sm:py-2 bg-white text-db-text text-sm focus:outline-none focus:border-db-blue transition-colors" />
        </div>
        <div class="flex flex-col text-left flex-shrink-0">
            <label for="fps" class="text-xs sm:text-sm text-db-text-secondary font-medium mb-1">Frame rate (FPS)</label>
            <input id="fps" type="number" min="1" max="60" value="15"
                class="border border-db-border rounded-lg px-2 sm:px-3 py-1.5 sm:py-2 bg-white text-db-text text-sm focus:outline-none focus:border-db-blue transition-colors" />
        </div>
        <div class="flex justify-center gap-2 flex-shrink-0">
            <button id="startBtn"
                class="flex-1 px-3 sm:px-4 py-2 sm:py-2.5 text-xs sm:text-sm font-medium text-white bg-db-blue rounded-lg border-none cursor-pointer transition-colors hover:bg-db-blue-hover active:scale-98">Start</button>
        </div>
        <div id="status" class="text-xs text-db-text-secondary break-words leading-snug min-h-[1.2em] flex-shrink-0">
        </div>
    </div>

    <script>
        const video = document.getElementById("video");
        const fpsInput = document.getElementById("fps");
        const status = document.getElementById("status");
        const startBtn = document.getElementById("startBtn");
        const streamIdInput = document.getElementById("streamId");

        let ws, canvas, ctx, streamInterval;
        let isPublishing = false;
        let currentStreamId = null;
        let streamIdDebounceTimer = null;
        let videoTrack = null;

        const CLIENT_ID_KEY = "client_id";
        const STREAM_ID_KEY = "stream_id";

        // Generate or retrieve client ID
        let clientId = localStorage.getItem(CLIENT_ID_KEY);
        if (!clientId) {
            clientId = "client_" + Math.random().toString(36).substring(2, 10);
            localStorage.setItem(CLIENT_ID_KEY, clientId);
        }

        // Generate fun stream ID - wait for library to load
        function generateStreamId() {
            let streamId = localStorage.getItem(STREAM_ID_KEY)?.trim();
            if ((!streamId || streamId === "undefined" || streamId === clientId)) {
                randomName = window["randomName"]?.trim();
                if (!!randomName) {
                    streamId = randomName;
                    localStorage.setItem(STREAM_ID_KEY, streamId);
                    console.log("Generated stream ID:", streamId);
                } else {
                    streamId = clientId;
                }
            }
            streamIdInput.value = streamId;
            currentStreamId = streamId;
        }

        // Start generating stream ID when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', generateStreamId);
        } else {
            generateStreamId();
        }

        // Also try when library loads
        window.addEventListener('load', () => {
            if (!localStorage.getItem(STREAM_ID_KEY)) {
                generateStreamId();
            }
        });

        // Fetch IP address from ipify.org
        let publicIP = null;
        async function fetchIP() {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                publicIP = data.ip;
                console.log("Public IP:", publicIP);
                return publicIP;
            } catch (err) {
                console.error("Error fetching IP:", err);
                return null;
            }
        }

        // Fetch IP on page load
        fetchIP();

        // Prevent touch scrolling/dragging on mobile
        document.addEventListener('touchstart', function (e) {
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                e.preventDefault();
            }
        }, { passive: false });

        document.addEventListener('touchmove', function (e) {
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                e.preventDefault();
            }
        }, { passive: false });

        document.addEventListener('touchend', function (e) {
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                e.preventDefault();
            }
        }, { passive: false });

        // Debounce function
        function debounce(func, wait) {
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(streamIdDebounceTimer);
                    func(...args);
                };
                clearTimeout(streamIdDebounceTimer);
                streamIdDebounceTimer = setTimeout(later, wait);
            };
        }

        const onStreamIdChange = () => {
            var newStreamId = streamIdInput.value?.trim();
            if (!!newStreamId && newStreamId === clientId) {
                newStreamId = null;
            }
            if (currentStreamId !== newStreamId) {
                if (!!newStreamId) {
                    localStorage.setItem(STREAM_ID_KEY, newStreamId);
                } else {
                    localStorage.removeItem(STREAM_ID_KEY);
                }
                currentStreamId = newStreamId;
                if (isPublishing) {
                    var textContent = `Connected as ${clientId}`;
                    if (!!currentStreamId) {
                        textContent += ` (stream_id=${currentStreamId})`;
                    }
                    status.textContent = textContent;
                }

            }
        }

        // Update stream ID when input changes (debounced)
        const updateStreamId = debounce(onStreamIdChange, 1000);

        // Persist stream ID on any change (immediate for blur, debounced for input)
        streamIdInput.addEventListener("input", () => {
            updateStreamId();
        });

        // Also persist stream ID changes when input loses focus
        streamIdInput.addEventListener("blur", () => {
            onStreamIdChange()
        });

        // Function to send a frame (used by both initial interval and FPS updates)
        function sendFrame() {
            if (!isPublishing || !ws || ws.readyState !== WebSocket.OPEN || !ctx || !canvas) return;

            // Update canvas dimensions to match video dimensions (preserves aspect ratio)
            const videoWidth = video.videoWidth || 0;
            const videoHeight = video.videoHeight || 0;
            if (videoWidth > 0 && videoHeight > 0) {
                canvas.width = videoWidth;
                canvas.height = videoHeight;
            }

            // Draw video to canvas at its natural size (preserves aspect ratio)
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const dataUrl = canvas.toDataURL("image/jpeg", 0.7);
            const headers = [
                { key: "client_id", value: clientId },
                { key: "stream_id", value: currentStreamId || clientId },
                { key: "width", value: String(videoWidth) },
                { key: "height", value: String(videoHeight) },
            ];
            if (publicIP) {
                headers.push({ key: "public_ip", value: publicIP });
            }
            const message = {
                headers: headers,
                key: { value: "foo", format: "string" },
                value: { value: dataUrl, format: "string" },
                messageId: `${clientId}_${Date.now()} `,
            };
            ws.send(JSON.stringify(message));
        }

        // Update FPS dynamically when changed during streaming
        fpsInput.addEventListener("input", () => {
            if (isPublishing && streamInterval) {
                // Restart interval with new FPS
                var fps = Math.min(Math.max(1, parseInt(fpsInput.value, 10)), 30);
                var intervalMs = 1000 / fps;
                clearInterval(streamInterval);
                streamInterval = setInterval(sendFrame, intervalMs);
            }
        });

        // Request camera access
        async function requestCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280, max: 1280 },
                        height: { ideal: 720, max: 720 },
                    },
                });
                video.srcObject = stream;
                video.play();

                videoTrack = stream.getVideoTracks()[0];
                const settings = videoTrack.getSettings();
                const actualRes = `${settings.width}x${settings.height} `;
                status.textContent = `Camera ready(${actualRes}), waiting for video to start...`;

                videoTrack.addEventListener("ended", () => {
                    status.textContent = "Camera access removed";
                    stop();
                });
                return true;
            } catch (err) {
                status.textContent = "Camera not available - click Start to request access";
                startBtn.classList.remove("hidden");
                return false;
            }
        }

        // Automatically request camera on load
        window.addEventListener("load", async () => {
            await requestCamera();
        });

        // When the video is actually playing (first frame ready)
        video.addEventListener("playing", () => {
            if (!isPublishing) start();
        });

        async function start() {
            try {
                if (isPublishing) return;

                if (!videoTrack || !video.srcObject) {
                    const cameraGranted = await requestCamera();
                    if (!cameraGranted || !videoTrack || !video.srcObject) {
                        startBtn.classList.remove("hidden");
                        return;
                    }
                }

                isPublishing = true;
                startBtn.classList.add("hidden");

                const stream = video.srcObject;
                if (!stream) return;

                currentStreamId = streamIdInput.value.trim() || streamIdInput.value || "Stream";

                canvas = document.createElement("canvas");
                // Set canvas dimensions to match video dimensions to preserve aspect ratio
                canvas.width = video.videoWidth || 640;
                canvas.height = video.videoHeight || 480;
                ctx = canvas.getContext("2d");

                const wsUrl = `wss://kws.lfpconnect.io/in?clientId=${clientId}&topic=source`;
                ws = new WebSocket(wsUrl);

                // Function to start/restart the frame interval
                function startFrameInterval() {
                    if (streamInterval) {
                        clearInterval(streamInterval);
                    }
                    const fps = parseInt(fpsInput.value, 10) || 15;
                    const intervalMs = 1000 / fps;
                    streamInterval = setInterval(sendFrame, intervalMs);
                }

                ws.onopen = () => {
                    status.textContent = `Connected as ${clientId} (stream_id=${currentStreamId})`;
                    startFrameInterval();
                };

                ws.onclose = () => {
                    status.textContent = "Disconnected";
                    stop();
                };

                ws.onerror = (err) => {
                    console.error("WebSocket error:", err);
                    status.textContent = "WebSocket error â€” see console.";
                    stop();
                };
            } catch (err) {
                console.error("Failed to start publishing:", err);
                status.textContent = "Failed to start publishing";
                isPublishing = false;
                startBtn.classList.remove("hidden");
            }
        }

        function stop() {
            if (!isPublishing && !videoTrack) return;
            isPublishing = false;
            startBtn.classList.remove("hidden");
            if (streamInterval) clearInterval(streamInterval);
            if (streamIdDebounceTimer) clearTimeout(streamIdDebounceTimer);
            if (ws && ws.readyState === WebSocket.OPEN) ws.close();
            const stream = video.srcObject;
            if (stream) {
                stream.getTracks().forEach((t) => {
                    if (t.readyState !== "ended") {
                        t.stop();
                    }
                });
            }
            video.srcObject = null;
            currentStreamId = null;
            videoTrack = null;
            if (status.textContent !== "Camera access removed") {
                status.textContent = "Stopped.";
            }
        }

        startBtn.onclick = start;
    </script>
</body>

</html>

</html>