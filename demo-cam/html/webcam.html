<!doctype html>
<html lang="en" class="h-full overflow-hidden">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <title>Webcam Stream Client</title>
    <style>
        * {
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        input,
        textarea {
            touch-action: manipulation;
            -webkit-user-select: auto;
            user-select: auto;
        }

        body {
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        html {
            overscroll-behavior: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }
    </style>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'db-blue': '#0094FF',
                        'db-blue-hover': '#007ACC',
                        'db-text': '#1F2937',
                        'db-text-secondary': '#6B7280',
                        'db-bg': '#FFFFFF',
                        'db-card': '#F7F9FC',
                        'db-border': '#E5E7EB',
                    }
                }
            }
        }
    </script>
    <script type="module">
        import {
            uniqueNamesGenerator,
            adjectives,
            colors,
            animals
        } from 'https://cdn.jsdelivr.net/npm/@joaomoreno/unique-names-generator@5.2.0/+esm';

        window.randomName = uniqueNamesGenerator({
            dictionaries: [adjectives, colors, animals],
            separator: "-",
            style: "lowerCase",
        });
    </script>
</head>

<body class="h-full w-full overflow-hidden bg-db-bg text-db-text font-sans p-1 sm:p-2 flex items-center justify-center">
    <div
        class="bg-db-card border border-db-border rounded-lg p-3 sm:p-4 w-full max-w-md max-h-full shadow-sm flex flex-col gap-2 sm:gap-3 overflow-hidden">
        <h2 class="text-lg sm:text-xl font-semibold text-db-blue m-0">IOT Stream</h2>
        <div
            class="flex-shrink-0 max-h-[40vh] sm:max-h-[50vh] flex items-center justify-center bg-black rounded-lg overflow-hidden my-1">
            <video id="video" autoplay playsinline muted
                class="w-full h-full max-w-full max-h-full object-contain rounded-lg"></video>
        </div>
        <div class="flex flex-col text-left flex-shrink-0">
            <label for="streamId" class="text-xs sm:text-sm text-db-text-secondary font-medium mb-1">Stream ID</label>
            <input id="streamId" type="text" placeholder="Stream ID"
                class="border border-db-border rounded-lg px-2 sm:px-3 py-1.5 sm:py-2 bg-white text-db-text text-sm focus:outline-none focus:border-db-blue transition-colors" />
        </div>
        <div class="flex flex-col text-left flex-shrink-0">
            <label for="fps" class="text-xs sm:text-sm text-db-text-secondary font-medium mb-1">Frame rate (FPS)</label>
            <input id="fps" type="number" min="1" max="60"
                class="border border-db-border rounded-lg px-2 sm:px-3 py-1.5 sm:py-2 bg-white text-db-text text-sm focus:outline-none focus:border-db-blue transition-colors" />
        </div>
        <div class="flex justify-center gap-2 flex-shrink-0">
            <button id="startBtn"
                class="hidden flex-1 px-3 sm:px-4 py-2 sm:py-2.5 text-xs sm:text-sm font-medium text-white bg-db-blue rounded-lg border-none cursor-pointer transition-colors hover:bg-db-blue-hover active:scale-98">Start</button>
            <button id="switchBtn" class="flex-1 px-3 py-2 text-xs font-medium text-white bg-db-blue rounded-lg">
                Switch camera
            </button>
        </div>
        <div id="status" class="text-xs text-db-text-secondary break-words leading-snug min-h-[1.2em] flex-shrink-0">
        </div>
    </div>

    <div id="devLogContainer"
        class="hidden fixed bottom-0 left-0 right-0 bg-black bg-opacity-90 text-white p-1 sm:p-2 max-h-32 sm:max-h-48 overflow-hidden z-50">
        <div class="flex items-center justify-between mb-1">
            <div class="text-xs font-mono text-green-400">Dev Log:</div>
            <button id="devLogToggle"
                class="text-green-400 text-xs px-2 py-0.5 border border-green-600 rounded">Minimize</button>
        </div>
        <textarea id="devLog" readonly
            class="w-full h-24 sm:h-40 bg-black text-green-400 text-xs font-mono p-1 sm:p-2 border border-green-600 resize-none overflow-y-auto"></textarea>
    </div>

    <script>
        // Check for dev mode
        const urlParams = new URLSearchParams(window.location.search);
        const isDevMode = urlParams.get('dev') === 'true';
        const devLogContainer = document.getElementById("devLogContainer");
        const devLogTextarea = document.getElementById("devLog");
        const devLogToggle = document.getElementById("devLogToggle");
        let devLogMinimized = false;

        if (isDevMode) {
            devLogContainer.classList.remove("hidden");
        }

        // Toggle dev log minimize
        if (devLogToggle) {
            devLogToggle.onclick = () => {
                devLogMinimized = !devLogMinimized;
                if (devLogMinimized) {
                    devLogTextarea.style.display = 'none';
                    devLogContainer.classList.remove("max-h-32", "sm:max-h-48");
                    devLogContainer.classList.add("max-h-8");
                    devLogToggle.textContent = "Expand";
                } else {
                    devLogTextarea.style.display = 'block';
                    devLogContainer.classList.remove("max-h-8");
                    devLogContainer.classList.add("max-h-32", "sm:max-h-48");
                    devLogToggle.textContent = "Minimize";
                }
            };
        }

        // Logging function: logs to console always, and to textarea if dev mode enabled
        // Signature: devLog(isError?, context?, ...args)
        // - First arg: boolean (true = error, false/undefined = info), removed from args
        // - Second arg: context string (null/undefined = omitted from logging)
        // - Rest: log message arguments
        function devLog(...args) {
            let isError = false;
            let context = null;

            // Check if first arg is boolean (error flag)
            if (typeof args[0] === 'boolean') {
                isError = args[0];
                args = args.slice(1);
            }

            // Next arg is context (if not null/undefined)
            if (args.length > 0 && args[0] !== null && args[0] !== undefined) {
                context = args[0];
                args = args.slice(1);
            } else if (args.length > 0 && (args[0] === null || args[0] === undefined)) {
                // Context is explicitly null/undefined, skip it
                args = args.slice(1);
            }

            const timestamp = new Date().toISOString();
            const prefix = context ? `[${context}]` : '';
            const level = isError ? 'ERROR' : 'INFO';
            const message = `[${timestamp}] [${level}] ${prefix} ${args.map(arg =>
                typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
            ).join(' ')}`;

            // Always log to browser console
            if (isError) {
                console.error(prefix, ...args);
            } else {
                console.log(prefix, ...args);
            }

            // Also append to dev log textarea if dev mode is on
            if (isDevMode && devLogTextarea) {
                devLogTextarea.value += message + '\n';
                devLogTextarea.scrollTop = devLogTextarea.scrollHeight;
            }
        }

        // DOM elements
        const video = document.getElementById("video");
        const fpsInput = document.getElementById("fps");
        const status = document.getElementById("status");
        const startBtn = document.getElementById("startBtn");
        const streamIdInput = document.getElementById("streamId");
        const switchBtn = document.getElementById("switchBtn");

        // State
        let ws, canvas, ctx, streamInterval;
        let isPublishing = false;
        let currentStreamId = null;
        let streamIdDebounceTimer = null;
        let videoTrack = null;
        let useEnvironment = true;
        let hasEnvironmentCamera = null;
        let publicIP = null;

        // Constants
        const CLIENT_ID_KEY = "client_id";
        const STREAM_ID_KEY = "stream_id";

        // Default values
        const DEFAULT_FPS = 5;
        const MIN_FPS = 1;
        const MAX_FPS = 30;
        const DEFAULT_CANVAS_WIDTH = 640;
        const DEFAULT_CANVAS_HEIGHT = 480;
        const VIDEO_WIDTH_IDEAL = 1280;
        const VIDEO_HEIGHT_IDEAL = 720;
        const JPEG_QUALITY = 0.7;

        // Set default FPS value in input if not already set
        if (!fpsInput.value) {
            fpsInput.value = DEFAULT_FPS;
        }

        // Initialize client ID
        let clientId = localStorage.getItem(CLIENT_ID_KEY);
        if (!clientId) {
            clientId = "client_" + Math.random().toString(36).substring(2, 10);
            localStorage.setItem(CLIENT_ID_KEY, clientId);
        }

        // Utility functions
        function updateStatus(message) {
            status.textContent = message;
        }

        // Stop all tracks in a media stream (camera/microphone)
        function stopStream(stream) {
            if (stream) {
                stream.getTracks().forEach(track => {
                    if (track.readyState !== "ended") track.stop();
                });
            }
        }

        // Stop publishing: close WebSocket, clear intervals/timers, but keep video stream
        function stopPublishing() {
            isPublishing = false;
            if (streamInterval) clearInterval(streamInterval);
            if (streamIdDebounceTimer) clearTimeout(streamIdDebounceTimer);
            if (ws && ws.readyState === WebSocket.OPEN) ws.close();
        }

        // Wait for video element to have valid dimensions (needed before capturing frames)
        function waitForVideoDimensions(timeoutMs = 5000) {
            return new Promise((resolve, reject) => {
                // Already has dimensions, resolve immediately
                if (video.videoWidth > 0 && video.videoHeight > 0) {
                    resolve();
                    return;
                }

                // Set timeout to prevent infinite waiting
                const timeout = setTimeout(() => {
                    cleanup();
                    reject(new Error("Timeout waiting for video dimensions"));
                }, timeoutMs);

                // Check dimensions when video metadata loads or starts playing
                const checkDimensions = () => {
                    if (video.videoWidth > 0 && video.videoHeight > 0) {
                        clearTimeout(timeout);
                        cleanup();
                        resolve();
                    }
                };

                const cleanup = () => {
                    video.removeEventListener("loadedmetadata", checkDimensions);
                    video.removeEventListener("playing", checkDimensions);
                };

                video.addEventListener("loadedmetadata", checkDimensions, { once: true });
                video.addEventListener("playing", checkDimensions, { once: true });
            });
        }

        // Determine which camera to use: environment (back) or user (front)
        function getFacingMode() {
            let facingMode;
            // First time: default to back camera
            if (hasEnvironmentCamera === null) {
                facingMode = { ideal: "environment" };
            } else {
                // Use back if available and requested, otherwise front
                facingMode = (hasEnvironmentCamera && useEnvironment)
                    ? { ideal: "environment" }
                    : { ideal: "user" };
            }
            devLog("getFacingMode", `Selected camera: ${facingMode.ideal} (useEnvironment: ${useEnvironment}, hasEnvironmentCamera: ${hasEnvironmentCamera})`);
            return facingMode;
        }

        // Check if device has multiple cameras (for showing switch button)
        async function checkMultipleCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                const hasMultiple = videoDevices.length > 1;
                devLog("checkMultipleCameras", `Found ${videoDevices.length} video device(s), multiple cameras: ${hasMultiple}`);
                return hasMultiple;
            } catch (err) {
                devLog(true, "checkMultipleCameras", "Error checking cameras:", err);
                return false;
            }
        }

        // Show/hide switch button based on camera availability
        function updateSwitchButtonVisibility() {
            const isVisible = !!hasEnvironmentCamera;
            switchBtn.classList.toggle("hidden", !hasEnvironmentCamera);
            devLog("updateSwitchButtonVisibility", `Switch button ${isVisible ? 'visible' : 'hidden'} (hasEnvironmentCamera: ${hasEnvironmentCamera})`);
        }

        // Start/restart frame capture interval based on FPS setting
        function startFrameInterval() {
            if (streamInterval) clearInterval(streamInterval);
            // Clamp FPS between min and max
            const fps = Math.min(Math.max(MIN_FPS, parseInt(fpsInput.value, 10) || DEFAULT_FPS), MAX_FPS);
            const intervalMs = 1000 / fps;
            devLog("startFrameInterval", `FPS: ${fps}, interval: ${intervalMs.toFixed(2)}ms`);
            streamInterval = setInterval(sendFrame, intervalMs);
        }

        // Stream ID management: generate or retrieve from localStorage
        function generateStreamId() {
            let streamId = localStorage.getItem(STREAM_ID_KEY)?.trim();
            // Generate new random name if none exists or invalid
            if (!streamId || streamId === "undefined" || streamId === clientId) {
                const randomName = window.randomName?.trim();
                streamId = randomName || clientId;
                if (randomName) {
                    localStorage.setItem(STREAM_ID_KEY, streamId);
                    devLog("generateStreamId", `Generated new stream ID: ${streamId}`);
                } else {
                    devLog("generateStreamId", `Using client ID as stream ID: ${streamId}`);
                }
            } else {
                devLog("generateStreamId", `Retrieved stream ID from storage: ${streamId}`);
            }
            streamIdInput.value = streamId;
            currentStreamId = streamId;
        }

        // Handle stream ID changes: save to localStorage and update status if publishing
        function onStreamIdChange() {
            let newStreamId = streamIdInput.value?.trim();
            // Don't allow stream ID to be same as client ID
            if (newStreamId === clientId) newStreamId = null;

            if (currentStreamId !== newStreamId) {
                devLog("onStreamIdChange", `Stream ID changed: "${currentStreamId}" -> "${newStreamId}"`);
                if (newStreamId) {
                    localStorage.setItem(STREAM_ID_KEY, newStreamId);
                } else {
                    localStorage.removeItem(STREAM_ID_KEY);
                }
                currentStreamId = newStreamId;
                // Update status message if currently publishing
                if (isPublishing) {
                    updateStatus(`Connected as ${clientId}${currentStreamId ? ` (stream_id=${currentStreamId})` : ''}`);
                }
            }
        }

        // Debounce function: delays execution until user stops typing
        function debounce(func, wait) {
            return function (...args) {
                clearTimeout(streamIdDebounceTimer);
                streamIdDebounceTimer = setTimeout(() => func(...args), wait);
            };
        }

        // Initialize stream ID
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', generateStreamId);
        } else {
            generateStreamId();
        }

        window.addEventListener('load', () => {
            if (!localStorage.getItem(STREAM_ID_KEY)) generateStreamId();
        });

        // Stream ID event listeners
        streamIdInput.addEventListener("input", debounce(onStreamIdChange, 1000));
        streamIdInput.addEventListener("blur", onStreamIdChange);

        // Fetch public IP
        fetch('https://api.ipify.org?format=json')
            .then(res => res.json())
            .then(data => { publicIP = data.ip; })
            .catch(() => { });

        // Camera management: requests camera access and returns promise that resolves when video is playing
        async function requestCamera() {
            devLog("requestCamera", "Starting camera request");
            try {
                const facingMode = getFacingMode();
                const constraints = {
                    video: {
                        facingMode: facingMode,
                        width: { ideal: VIDEO_WIDTH_IDEAL, max: VIDEO_WIDTH_IDEAL },
                        height: { ideal: VIDEO_HEIGHT_IDEAL, max: VIDEO_HEIGHT_IDEAL }
                    }
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);

                // On first call, check if device has multiple cameras (for switch button)
                if (hasEnvironmentCamera === null) {
                    hasEnvironmentCamera = await checkMultipleCameras();
                    devLog("requestCamera", `Multiple cameras detected: ${hasEnvironmentCamera}`);
                    updateSwitchButtonVisibility();
                }

                // Stop previous stream and set new one
                stopStream(video.srcObject);
                video.srcObject = stream;
                videoTrack = stream.getVideoTracks()[0];
                const settings = videoTrack.getSettings();
                updateStatus(`Camera ready(${settings.width}x${settings.height}), starting video...`);

                // Handle camera being revoked/ended by user
                videoTrack.addEventListener("ended", () => {
                    updateStatus("Camera access removed");
                    stop();
                });

                // Wait for video element to actually start playing before resolving
                return new Promise((resolve, reject) => {
                    const cleanup = () => {
                        video.removeEventListener("playing", onPlaying);
                        video.removeEventListener("error", onError);
                    };

                    const onPlaying = () => {
                        cleanup();
                        resolve(true);
                    };

                    const onError = (err) => {
                        devLog(true, "requestCamera", "Video error:", err);
                        cleanup();
                        reject(err);
                    };

                    video.addEventListener("playing", onPlaying, { once: true });
                    video.addEventListener("error", onError, { once: true });
                    video.play().catch(err => {
                        devLog(true, "requestCamera", "video.play() failed:", err);
                        cleanup();
                        reject(err);
                    });
                });
            } catch (err) {
                devLog(true, "requestCamera", "Error:", err);
                // If back camera fails and we haven't tried front camera yet, retry with front
                if ((hasEnvironmentCamera === null || hasEnvironmentCamera) && useEnvironment) {
                    useEnvironment = false;
                    return await requestCamera();
                }
                updateStatus(`Camera error: ${err.message}`);
                startBtn.classList.remove("hidden");
                return false;
            }
        }

        // Frame capture and sending: captures video frame, converts to JPEG, sends via WebSocket
        function sendFrame() {
            // Early return if not ready to send
            if (!isPublishing || !ws || ws.readyState !== WebSocket.OPEN || !ctx || !canvas) return;

            const videoWidth = video.videoWidth || 0;
            const videoHeight = video.videoHeight || 0;
            // Update canvas size to match video dimensions
            if (videoWidth > 0 && videoHeight > 0) {
                canvas.width = videoWidth;
                canvas.height = videoHeight;
            }

            // Draw current video frame to canvas
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // Build message headers with metadata
            const headers = [
                { key: "client_id", value: clientId },
                { key: "stream_id", value: currentStreamId || clientId },
                { key: "width", value: String(videoWidth) },
                { key: "height", value: String(videoHeight) },
            ];
            if (publicIP) headers.push({ key: "public_ip", value: publicIP });

            // Send frame as base64 JPEG via WebSocket
            ws.send(JSON.stringify({
                headers: headers,
                key: { value: "foo", format: "string" },
                value: { value: canvas.toDataURL("image/jpeg", JPEG_QUALITY), format: "string" },
                messageId: `${clientId}_${Date.now()} `,
            }));
        }

        // FPS update handler
        fpsInput.addEventListener("input", () => {
            const newFps = parseInt(fpsInput.value, 10) || DEFAULT_FPS;
            devLog("fpsInput", `FPS changed to: ${newFps}`);
            if (isPublishing) {
                devLog("fpsInput", "Restarting frame interval with new FPS");
                startFrameInterval();
            }
        });

        // Publishing control: starts WebSocket connection and frame capture interval
        async function start() {
            if (isPublishing) return;

            try {
                // Request camera if not already available
                if (!videoTrack || !video.srcObject) {
                    const cameraGranted = await requestCamera();
                    if (!cameraGranted || !videoTrack || !video.srcObject) {
                        startBtn.classList.remove("hidden");
                        return;
                    }
                }

                isPublishing = true;
                devLog("start", "Publishing started");
                startBtn.classList.add("hidden");
                currentStreamId = streamIdInput.value.trim() || "Stream";

                // Initialize canvas for frame capture
                if (!canvas) {
                    canvas = document.createElement("canvas");
                    ctx = canvas.getContext("2d");
                    devLog("start", "Canvas created");
                }
                canvas.width = video.videoWidth || DEFAULT_CANVAS_WIDTH;
                canvas.height = video.videoHeight || DEFAULT_CANVAS_HEIGHT;
                devLog("start", `Canvas size: ${canvas.width}x${canvas.height}`);

                // Connect to WebSocket server for streaming
                ws = new WebSocket(`wss://kws.lfpconnect.io/in?clientId=${clientId}&topic=source`);

                ws.onopen = () => {
                    updateStatus(`Connected as ${clientId}${currentStreamId ? ` (stream_id=${currentStreamId})` : ''}`);
                    startFrameInterval(); // Start sending frames at configured FPS
                };

                ws.onclose = (event) => {
                    devLog(true, "start", "WebSocket closed:", event.code, event.reason);
                    updateStatus(`Disconnected (code: ${event.code})`);
                    stop();
                };

                ws.onerror = () => {
                    devLog(true, "start", "WebSocket error");
                    updateStatus("WebSocket error â€” see console.");
                    stop();
                };
            } catch (err) {
                devLog(true, "start", "Failed:", err);
                updateStatus(`Failed to start: ${err.message}`);
                isPublishing = false;
                // Show start button if camera access was denied
                if (!videoTrack || !video.srcObject) {
                    startBtn.classList.remove("hidden");
                }
            }
        }

        // Stop publishing and clean up resources
        function stop() {
            if (!isPublishing && !videoTrack) return;
            const wasPublishing = isPublishing;
            stopPublishing(); // Close WebSocket, clear intervals
            stopStream(video.srcObject); // Stop camera stream
            video.srcObject = null;
            videoTrack = null;
            if (wasPublishing) {
                devLog("stop", "Publishing stopped");
            }
            // Keep start button hidden - video will auto-start when playing event fires
            if (status.textContent !== "Camera access removed") {
                updateStatus("Stopped.");
            }
        }

        // Switch between front/back camera and auto-restart publishing if it was active
        async function switchCamera() {
            const wasPublishing = isPublishing;
            const oldCamera = useEnvironment ? "back" : "front";
            devLog("switchCamera", `Switching camera from ${oldCamera} (wasPublishing: ${wasPublishing})`);

            if (wasPublishing) stopPublishing(); // Stop publishing but keep video stream

            useEnvironment = !useEnvironment; // Toggle camera preference
            const newCamera = useEnvironment ? "back" : "front";
            devLog("switchCamera", `Switching to ${newCamera} camera`);
            startBtn.classList.add("hidden");

            try {
                const cameraGranted = await requestCamera();
                if (!cameraGranted) {
                    devLog(true, "switchCamera", "Camera access denied");
                    startBtn.classList.remove("hidden");
                    return;
                }

                devLog("switchCamera", `Camera switched successfully to ${newCamera}`);
                // Wait for video to have dimensions before starting capture
                await waitForVideoDimensions();
                if (videoTrack && video.srcObject) {
                    devLog("switchCamera", "Auto-restarting publishing with new camera");
                    await start(); // Auto-restart publishing with new camera
                }
            } catch (err) {
                devLog(true, "switchCamera", "Error:", err);
                updateStatus(`Camera switch error: ${err.message}`);
                startBtn.classList.remove("hidden");
            }
        }

        // Event listeners
        // Request camera on page load
        window.addEventListener("load", requestCamera);

        // Auto-start publishing when video starts playing (if not already publishing)
        video.addEventListener("playing", () => {
            if (!isPublishing) start();
        });

        startBtn.onclick = start;
        switchBtn.onclick = switchCamera;
    </script>
</body>

</html>