<!doctype html>
<html lang="en" class="h-full overflow-hidden">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Detection Viewer</title>
    <style>
        * {
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        html {
            overscroll-behavior: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }
    </style>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'db-blue': '#0094FF',
                        'db-blue-hover': '#007ACC',
                        'db-text': '#1F2937',
                        'db-text-secondary': '#6B7280',
                        'db-bg': '#FFFFFF',
                        'db-card': '#F7F9FC',
                        'db-border': '#E5E7EB',
                    }
                }
            }
        }
    </script>
</head>

<body class="h-full w-full overflow-hidden bg-db-bg text-db-text font-sans p-2 sm:p-4">
    <div class="h-full flex flex-col gap-2 sm:gap-3">
        <h2 class="text-lg sm:text-xl font-semibold text-db-blue m-0">Detection Viewer</h2>
        <div id="status" class="text-xs text-db-text-secondary">Connecting...</div>
        <div id="detections"
            class="flex-1 overflow-y-auto grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-2 sm:gap-3">
            <!-- Detection cards will be inserted here -->
        </div>
    </div>

    <script>
        // Constants
        // Detect if opened from file:// and use localhost:8000, otherwise use relative URL
        const SSE_URL = window.location.protocol === 'file:'
            ? "http://localhost:8000/sse/detections?offset=250"
            : "/sse/detections?offset=100";
        const MAX_IMAGE_WIDTH = 400;
        const MAX_IMAGE_HEIGHT = 300;

        // State: stream_id -> detection_type -> { data, messageTimestamp, element }
        const detections = new Map();
        // Labels per card: stream_id -> detection_type -> Set<labels>
        const cardLabels = new Map();
        let eventSource = null;

        // DOM elements
        const status = document.getElementById("status");
        const detectionsContainer = document.getElementById("detections");

        // Update status message
        function updateStatus(message) {
            status.textContent = message;
        }

        // Update tags display for a specific card (stream_id + detection_type)
        function updateTagsForCard(streamId, detectionType) {
            const streamLabels = cardLabels.get(streamId);
            if (!streamLabels) return;

            const labels = streamLabels.get(detectionType);
            if (!labels) return;

            // Get sorted array of labels
            const sortedLabels = Array.from(labels).sort();

            // Get the specific card
            const streamDetections = detections.get(streamId);
            if (!streamDetections) return;

            const detection = streamDetections.get(detectionType);
            if (!detection) return;

            const card = detection.element;
            const tagsContainer = card.querySelector('.tags-container');
            if (!tagsContainer) return;

            // Clear existing tags
            tagsContainer.innerHTML = '';

            // Create tag elements
            sortedLabels.forEach(label => {
                const tag = document.createElement("span");
                tag.className = "inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-db-blue text-white";
                tag.textContent = label;
                tagsContainer.appendChild(tag);
            });
        }

        // Create detection card element
        function createDetectionCard(streamId, detectionType, message) {
            const value = message.value; // SSE message has value directly
            const card = document.createElement("div");
            card.className = "bg-db-card border border-db-border rounded-lg p-2 sm:p-3 shadow-sm self-start";
            card.dataset.streamId = streamId;
            card.dataset.detectionType = detectionType;

            const header = document.createElement("div");
            header.className = "flex items-center justify-between mb-2";

            const title = document.createElement("div");
            title.className = "text-xs sm:text-sm font-semibold text-db-text";
            title.textContent = `${streamId} - ${detectionType}`;

            const score = document.createElement("div");
            score.className = "text-xs text-db-text-secondary";
            score.textContent = `Score: ${((value?.score || 0) * 100).toFixed(1)}%`;

            header.appendChild(title);
            header.appendChild(score);

            // Tags container (will be populated when labels are added)
            const tagsContainer = document.createElement("div");
            tagsContainer.className = "tags-container flex flex-wrap gap-1.5 mb-2";

            const imageContainer = document.createElement("div");
            imageContainer.className = "w-full flex items-center justify-center bg-black rounded overflow-hidden mb-2";

            const img = document.createElement("img");
            img.className = "max-w-full max-h-full object-contain";
            img.style.maxWidth = `${MAX_IMAGE_WIDTH}px`;
            img.style.maxHeight = `${MAX_IMAGE_HEIGHT}px`;
            if (value?.frame_image_annotated) {
                img.src = `data:image/jpeg;base64,${value.frame_image_annotated}`;
            }
            img.alt = `${detectionType} detection`;

            imageContainer.appendChild(img);

            const metadata = document.createElement("div");
            metadata.className = "text-xs text-db-text-secondary space-y-1";

            if (value?.box) {
                const boxInfo = document.createElement("div");
                boxInfo.textContent = `Box: (${value.box.x1}, ${value.box.y1}) - (${value.box.x2}, ${value.box.y2})`;
                metadata.appendChild(boxInfo);
            }

            if (value?.label) {
                const labelInfo = document.createElement("div");
                labelInfo.textContent = `Label: ${value.label}`;
                metadata.appendChild(labelInfo);
            }

            const timestampInfo = document.createElement("div");
            if (value?.timestamp) {
                timestampInfo.textContent = `Time: ${new Date(value.timestamp).toLocaleTimeString()}`;
            }
            metadata.appendChild(timestampInfo);

            card.appendChild(header);
            card.appendChild(tagsContainer);
            card.appendChild(imageContainer);
            card.appendChild(metadata);

            return card;
        }

        // Update or create detection card
        function updateDetection(message) {
            try {
                const value = message.value; // SSE message has value directly
                if (!value) return;

                const streamId = value.metadata_parsed?.stream_id;
                const detectionType = value.detection_type;

                if (!streamId || !detectionType) return;

                // Add label to this card's label set if present
                if (value.label) {
                    if (!cardLabels.has(streamId)) {
                        cardLabels.set(streamId, new Map());
                    }
                    const streamLabels = cardLabels.get(streamId);
                    if (!streamLabels.has(detectionType)) {
                        streamLabels.set(detectionType, new Set());
                    }
                    const labels = streamLabels.get(detectionType);
                    const labelAdded = !labels.has(value.label);
                    labels.add(value.label);
                    // Only update tags if a new label was added
                    if (labelAdded) {
                        updateTagsForCard(streamId, detectionType);
                    }
                }

                // Get message timestamp (use parsed_timestamp if available, otherwise timestamp)
                const messageTimestamp = value.parsed_timestamp
                    ? new Date(value.parsed_timestamp).getTime()
                    : (value.timestamp ? new Date(value.timestamp).getTime() : Date.now());

                // Get or create stream_id map
                if (!detections.has(streamId)) {
                    detections.set(streamId, new Map());
                }
                const streamDetections = detections.get(streamId);

                // Update or create detection
                const existing = streamDetections.get(detectionType);
                if (existing) {
                    // Only update image if new timestamp is greater than existing
                    const shouldUpdateImage = messageTimestamp > existing.messageTimestamp;

                    // Update existing card
                    existing.data = message;
                    existing.messageTimestamp = messageTimestamp;
                    const card = existing.element;

                    // Update image only if timestamp is newer
                    if (shouldUpdateImage) {
                        const img = card.querySelector("img");
                        if (img && value.frame_image_annotated) {
                            img.src = `data:image/jpeg;base64,${value.frame_image_annotated}`;
                        }
                    }

                    // Always update score
                    const header = card.querySelector(".flex.items-center.justify-between");
                    if (header) {
                        const scoreEl = header.querySelector(".text-xs.text-db-text-secondary");
                        if (scoreEl && value.score !== undefined) {
                            scoreEl.textContent = `Score: ${(value.score * 100).toFixed(1)}%`;
                        }
                    }

                    // Always update timestamp display
                    const metadata = card.querySelector(".text-xs.text-db-text-secondary.space-y-1");
                    if (metadata && value.timestamp) {
                        const timestampEl = metadata.lastElementChild;
                        if (timestampEl) {
                            timestampEl.textContent = `Time: ${new Date(value.timestamp).toLocaleTimeString()}`;
                        }
                    }
                } else {
                    // Create new card
                    const card = createDetectionCard(streamId, detectionType, message);
                    streamDetections.set(detectionType, {
                        data: message,
                        messageTimestamp: messageTimestamp,
                        element: card
                    });

                    // Append to grid (grid will handle wrapping)
                    detectionsContainer.appendChild(card);

                    // Update tags for this card if labels exist
                    const streamLabels = cardLabels.get(streamId);
                    if (streamLabels && streamLabels.has(detectionType)) {
                        updateTagsForCard(streamId, detectionType);
                    }
                }
            } catch (err) {
                console.error("Error updating detection:", err);
            }
        }


        // Connect to SSE endpoint
        function connect() {
            updateStatus("Connecting...");

            // Close existing connection if any
            if (eventSource) {
                eventSource.close();
            }

            eventSource = new EventSource(SSE_URL);

            eventSource.onopen = () => {
                updateStatus("Connected");
            };

            eventSource.onmessage = (event) => {
                try {
                    // SSE messages come as "data: {...}\n\n"
                    // EventSource automatically parses the "data:" prefix
                    const message = JSON.parse(event.data);

                    // Skip keepalive messages (empty data)
                    if (!message || Object.keys(message).length === 0) {
                        return;
                    }

                    // Handle error messages from server
                    if (message.error) {
                        console.error("Server error:", message.error);
                        updateStatus(`Error: ${message.error}`);
                        return;
                    }

                    updateDetection(message);
                } catch (err) {
                    console.error("Error parsing message:", err);
                }
            };

            eventSource.onerror = (err) => {
                console.error("SSE error:", err);
                updateStatus("Connection error - reconnecting...");
                // EventSource will automatically reconnect, but we can also manually reconnect
                setTimeout(() => {
                    if (eventSource && eventSource.readyState === EventSource.CLOSED) {
                        connect();
                    }
                }, 1000);
            };
        }

        // Start connection
        connect();
    </script>
</body>

</html>